# TIL

=============================================

## 2021-03-28 (월)

### HTML5의 File API

`<input type="file">`로 명시된 HTMLInputElement API는 내부 속성인 files을 통하여 FileList API에 접근할 수 있다\
FileList API는 0개 이상의 파일 목록을 관리하는 유사 배열이다. 이들 각각의 요소는 File API의 인스턴스로 구성된다\
File API는 파일의 바이너리 데이터를 담고 있으며 window.atoi() 메소드를 이용하여 base64 포멧으로도 변환 가능하다\
\
File API에서 파일 정보는 Blob으로 구현되어 있다. 그러므로 File 생성자도 블롭을 인자로 받는다. 아래와 같다\
`new File([blob], "filename")`


### HTML5의 Base64 API

웹브라우저에서 이미지를 base64로 표현하고 싶을 때 두가지 경우로 나누어 생각할 수 있다
1. 로컬에서 File API로 불러온 이미지를 base64로 변환
2. 네트워크로 다운로드받은 이미지를 변환

로컬 이미지는 File객체를 인자로 받아서 base64를 리턴하는 FileReader.readAsDataURL() 메소드를 사용하면 변환 가능하다\
네트워크로 다운받은 파일의 base64변환도 이와 유사하다

1. 먼저 fetch로 이미지를 다운로드 받는다
2. blob 객체를 생성한다. `fetch(url).then(response => response.blob())` 으로 생성할 수 있다
3. FileReader API의 `readAsDataURL()` 메소드에 블롭을 인자로 넣고 호출하면 blob이 base64 문자열로 변환된다

하지만 서버측에서 다른 도메인의 다운로드를 금지한 경우 다른 도메인에서 fetch를 통한 이미지 다운로드가 불가능하다
이 경우는 서버의 리스폰스 헤더에 `Access-Control-Allow-Origin: *` 을 추가해주면 정상적으로 다운로드된다

=============================================

## 2021-03-27 (일)


### WebRTC와 WebSocket

WebRTC와 웹소켓은 둘 다 실시간 통신을 목적으로 구현되었다\
본래 웹소켓이 먼저 만들어졌지만 웹소켓의 한계로 인하여 WebRTC가 고안되었다\
웹소켓의 한계는 자명하다. 통신을 할 때 반드시 서버를 경유해야 한다. 클라이언트 간의 p2p통신이 목적인 경우에도 필연적으로 서버를 경유하는 딜레이가 발생한다\
이런 불필요한 딜레이는 `멀티플레이 온라인 게임`처럼 실시간성이 중요한 프로그램에 치명적인 영향을 준다. 격투게임을 예로 들면, 격투게임 프로게이머들의 승부는 1프레임 단위로 승리가 갈린다. 60프레임 기반 게임에서 1프레임은 16.6ms이므로 만일 통신 딜레이가 16.6ms를 초과하면 정상적인 게임 플레이에 악영향을 준다. 하지만 16.6ms 미만의 고속 p2p 통신은 서버를 경유하는 웹소켓 방식으로는 구현이 거의 불가능하다\
WebRTC는 통신에 서버를 경유하지 않으므로 보다 나은 실시간성을 보장한다\
개인적인 생각이지만 WebRTC가 사용되는 대부분의 경우는 게임 구현일 것으로 예상한다

=============================================

## 2021-03-26 (토)

### WebVR과 WebXR

WebVR은 deprecated되었고 VR관련 API는 WebXR로 대체되었다\
WebXR은 VR전용기기와의 세션을 생성하는 통신 인터페이스이다. WebXR자체로 렌더링을 수행할수는 없으며 WebXR은 그저 데이터를 송수신한다\
실질적인 3D렌더링은 WebGPU등의 API가 담당한다

=============================================